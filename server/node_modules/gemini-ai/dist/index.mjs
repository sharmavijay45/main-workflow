var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __knownSymbol = (name, symbol) => {
  return (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __forAwait = (obj, it, method) => (it = obj[__knownSymbol("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);

// src/types.ts
var SafetyThreshold = /* @__PURE__ */ ((SafetyThreshold2) => {
  SafetyThreshold2["BLOCK_MOST"] = "BLOCK_LOW_AND_ABOVE";
  SafetyThreshold2["BLOCK_SOME"] = "BLOCK_MEDIUM_AND_ABOVE";
  SafetyThreshold2["BLOCK_FEW"] = "BLOCK_ONLY_HIGH";
  SafetyThreshold2["BLOCK_NONE"] = "BLOCK_NONE";
  return SafetyThreshold2;
})(SafetyThreshold || {});
var SchemaType = /* @__PURE__ */ ((SchemaType2) => {
  SchemaType2["STRING"] = "STRING";
  SchemaType2["NUMBER"] = "NUMBER";
  SchemaType2["INTEGER"] = "INTEGER";
  SchemaType2["BOOLEAN"] = "BOOLEAN";
  SchemaType2["ARRAY"] = "ARRAY";
  SchemaType2["OBJECT"] = "OBJECT";
  return SchemaType2;
})(SchemaType || {});

// src/utils.ts
import { fileTypeFromBuffer } from "file-type";
var getFileType = async (buffer) => {
  const fileType = await fileTypeFromBuffer(buffer);
  const validMediaFormats = [
    "image/png",
    "image/jpeg",
    "image/webp",
    "image/heic",
    "image/heif",
    "audio/wav",
    "audio/mp3",
    "audio/mpeg",
    "audio/aiff",
    "audio/aac",
    "audio/ogg",
    "audio/flac",
    "video/mp4",
    "video/mpeg",
    "video/mov",
    "video/avi",
    "video/x-flv",
    "video/mpg",
    "video/webm",
    "video/wmv",
    "video/3gpp"
  ];
  const formatMap = {
    "audio/mpeg": "audio/mp3"
  };
  const format = formatMap[fileType == null ? void 0 : fileType.mime] || (fileType == null ? void 0 : fileType.mime);
  if (format === void 0 || !validMediaFormats.includes(format))
    throw new Error(
      "Please provide a valid file format that is accepted by Gemini. Learn more about valid formats here: https://ai.google.dev/gemini-api/docs/prompting_with_media?lang=node#supported_file_formats"
    );
  return format;
};
var SafetyError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "SafetyError";
  }
};
var handleReader = async (response, cb) => {
  if (!response.body)
    throw new Error(
      `An error occurred when attempting to read Gemini's response ${await response.text()}`
    );
  const decoder = new TextDecoder("utf-8");
  try {
    const reader = response.body.getReader();
    await reader.read().then(function processText({ done, value }) {
      if (done)
        return;
      cb(JSON.parse(decoder.decode(value).replace(/^data: /, "")));
      return reader.read().then(processText);
    });
  } catch (e) {
    if (e instanceof SafetyError)
      throw e;
    try {
      try {
        for (var iter = __forAwait(response.body), more, temp, error; more = !(temp = await iter.next()).done; more = false) {
          const chunk = temp.value;
          cb(JSON.parse(decoder.decode(chunk).replace(/^data: /, "")));
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && await temp.call(iter);
        } finally {
          if (error)
            throw error[0];
        }
      }
    } catch (err) {
      if (err instanceof SafetyError)
        throw err;
      throw new Error(
        `An error occurred when attempting to stream content from Gemini: ${err.stack}`
      );
    }
  }
};
var pairToMessage = (message) => {
  return [
    {
      parts: [{ text: message[0] }],
      role: "user"
    },
    {
      parts: [{ text: message[1] }],
      role: "model"
    }
  ];
};

// src/index.ts
var uploadFile = async ({
  file,
  mimeType,
  gemini
}) => {
  const BASE_URL = "https://generativelanguage.googleapis.com";
  function generateBoundary() {
    let str = "";
    for (let i = 0; i < 2; i++) {
      str = str + Math.random().toString().slice(2);
    }
    return str;
  }
  const boundary = generateBoundary();
  const generateBlob = (boundary2, file2, mime) => new Blob([
    `--${boundary2}\r
Content-Type: application/json; charset=utf-8\r
\r
${JSON.stringify(
      {
        file: {
          mimeType: mime
        }
      }
    )}\r
--${boundary2}\r
Content-Type: ${mime}\r
\r
`,
    file2,
    `\r
--${boundary2}--`
  ]);
  const fileSendDataRaw = await gemini.fetch(`${BASE_URL}/upload/${gemini.apiVersion}/files?key=${gemini.key}`, {
    method: "POST",
    headers: {
      "Content-Type": `multipart/related; boundary=${boundary}`,
      "X-Goog-Upload-Protocol": "multipart"
    },
    body: generateBlob(boundary, file, mimeType)
  }).then((res) => res.json());
  const fileSendData = fileSendDataRaw.file;
  let waitTime = 250;
  const MAX_BACKOFF = 5e3;
  while (true) {
    try {
      const url = `${BASE_URL}/${gemini.apiVersion}/${fileSendData.name}?key=${gemini.key}`;
      const response = await gemini.fetch(url, { method: "GET" });
      const data = await response.json();
      if (data.error) {
        throw new Error(
          `Google's File API responded with an error: ${data.error.message}`
        );
      }
      if (data.state === "ACTIVE")
        break;
      await new Promise((resolve) => setTimeout(resolve, waitTime));
      waitTime = Math.min(waitTime * 1.5, MAX_BACKOFF);
    } catch (error) {
      throw new Error(
        `An error occurred while uploading to Google's File API: ${error.message}`
      );
    }
  }
  return fileSendData.uri;
};
var messageToParts = async (messages, gemini) => {
  const parts = [];
  let totalBytes = 0;
  for (const msg of messages) {
    if (typeof msg === "string") {
      parts.push({ text: msg });
    } else if (msg instanceof ArrayBuffer || msg instanceof Uint8Array) {
      totalBytes += Buffer.from(msg).byteLength;
      const mimeType = await getFileType(msg);
      if (!mimeType.startsWith("video")) {
        parts.push({
          inline_data: {
            mime_type: await getFileType(msg),
            data: Buffer.from(msg).toString("base64")
          }
        });
      } else {
        const fileURI = await uploadFile({
          file: msg,
          mimeType,
          gemini
        });
        parts.push({
          fileData: {
            mime_type: mimeType,
            fileUri: fileURI
          }
        });
      }
    }
  }
  if (totalBytes > 20 * 1024 * 1024) {
    for (const idx in parts) {
      const part = parts[idx];
      if (part.inline_data) {
        const fileURI = await uploadFile({
          file: Buffer.from(part.inline_data.data, "base64"),
          mimeType: part.inline_data.mime_type,
          gemini
        });
        parts[idx] = {
          fileData: {
            mime_type: part.inline_data.mime_type,
            fileUri: fileURI
          }
        };
      }
    }
  }
  return parts;
};
var _Gemini = class _Gemini {
  constructor(key, options = {}) {
    this.getTextObject = (response) => response.candidates[0].content.parts[0];
    this.switchFormat = (format = _Gemini.TEXT) => (response) => {
      if (response.candidates[0].finishReason === "SAFETY") {
        throw new SafetyError(
          `Your prompt was blocked by Google. Here are the Harm Categories: 
${JSON.stringify(
            response.candidates[0].safetyRatings,
            null,
            4
          )}`
        );
      }
      switch (format) {
        case _Gemini.TEXT:
          return this.getTextObject(response).text;
        case _Gemini.JSON:
          return response;
      }
    };
    this.getText = this.switchFormat(_Gemini.TEXT);
    this.handleStream = async (response, format, cb) => {
      const formatter = this.switchFormat(format);
      let res;
      let text = "";
      await handleReader(response, (value) => {
        res = value;
        text += this.getText(value);
        cb(formatter(value));
      });
      this.getTextObject(res).text = text;
      return formatter(res);
    };
    if (!options.fetch && typeof fetch !== "function") {
      throw new Error(
        "Fetch is not defined globally. Please provide a polyfill. Learn more here: https://github.com/EvanZhouDev/gemini-ai?tab=readme-ov-file#how-to-polyfill-fetch"
      );
    }
    const parsedOptions = __spreadValues(__spreadValues({}, {
      apiVersion: "v1beta",
      fetch: typeof fetch === "function" ? fetch : options.fetch
    }), options);
    this.key = key;
    this.fetch = parsedOptions.fetch;
    this.apiVersion = parsedOptions.apiVersion;
  }
  async query(model, command, body) {
    const opts = {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(body)
    };
    const url = new URL(
      `https://generativelanguage.googleapis.com/${this.apiVersion}/models/${model}:${command}`
    );
    url.searchParams.append("key", this.key);
    if (command === "streamGenerateContent" /* StreamGenerate */)
      url.searchParams.append("alt", "sse");
    const response = await this.fetch(url.toString(), opts);
    if (!response.ok) {
      throw new Error(
        `There was an error when querying Gemini.
${await response.text()}`
      );
    }
    return response;
  }
  async count(message, options = {}) {
    const parsedOptions = __spreadValues(__spreadValues({}, {
      model: "gemini-1.5-flash-latest"
    }), options);
    const body = {
      contents: [
        {
          parts: [{ text: message }],
          role: "user"
        }
      ]
    };
    const response = await this.query(
      parsedOptions.model,
      "countTokens" /* Count */,
      body
    );
    const output = await response.json();
    return output.totalTokens;
  }
  async embed(message, options = {}) {
    const parsedOptions = __spreadValues(__spreadValues({}, {
      model: "embedding-001"
    }), options);
    const body = {
      model: `models/${parsedOptions.model}`,
      content: {
        parts: [{ text: message }],
        role: "user"
      }
    };
    const response = await this.query(
      parsedOptions.model,
      "embedContent" /* Embed */,
      body
    );
    const output = await response.json();
    return output.embedding.values;
  }
  async ask(message, options = {}) {
    const parsedOptions = __spreadValues(__spreadValues({}, {
      model: "gemini-1.5-flash-latest",
      temperature: 1,
      topP: 0.94,
      topK: 32,
      format: _Gemini.TEXT,
      maxOutputTokens: 2048,
      data: [],
      messages: [],
      safetySettings: {
        hate: _Gemini.SafetyThreshold.BLOCK_SOME,
        sexual: _Gemini.SafetyThreshold.BLOCK_SOME,
        harassment: _Gemini.SafetyThreshold.BLOCK_SOME,
        dangerous: _Gemini.SafetyThreshold.BLOCK_SOME
      },
      systemInstruction: "",
      jsonSchema: void 0
    }), options);
    const safetySettings = [
      {
        category: "HARM_CATEGORY_HATE_SPEECH" /* HateSpeech */,
        threshold: parsedOptions.safetySettings.hate
      },
      {
        category: "HARM_CATEGORY_SEXUALLY_EXPLICIT" /* SexuallyExplicit */,
        threshold: parsedOptions.safetySettings.sexual
      },
      {
        category: "HARM_CATEGORY_HARASSMENT" /* Harassment */,
        threshold: parsedOptions.safetySettings.harassment
      },
      {
        category: "HARM_CATEGORY_DANGEROUS_CONTENT" /* DangerousContent */,
        threshold: parsedOptions.safetySettings.dangerous
      }
    ];
    const command = parsedOptions.stream ? "streamGenerateContent" /* StreamGenerate */ : "generateContent" /* Generate */;
    const contents = [
      ...parsedOptions.messages.flatMap(
        (msg) => {
          if (Array.isArray(msg)) {
            return pairToMessage(msg);
          }
          return msg;
        }
      )
    ];
    if (!Array.isArray(message) && typeof message !== "string") {
      if (message.role === "model")
        throw new Error("Please prompt with role as 'user'");
      contents.push(message);
    } else {
      const messageParts = [message, parsedOptions.data].flat();
      const parts = await messageToParts(messageParts, this);
      if (parsedOptions.jsonSchema && parsedOptions.model !== "gemini-1.5-pro-latest") {
        parts.push({
          text: `Use this JSON schema: <JSONSchema>${JSON.stringify(
            parsedOptions.jsonSchema
          )}</JSONSchema>`
        });
      }
      contents.push({
        parts,
        role: "user"
      });
    }
    const body = {
      contents,
      generationConfig: {
        temperature: parsedOptions.temperature,
        maxOutputTokens: parsedOptions.maxOutputTokens,
        topP: parsedOptions.topP,
        topK: parsedOptions.topK,
        responseMimeType: parsedOptions.jsonSchema ? "application/json" : void 0,
        responseSchema: typeof parsedOptions.jsonSchema === "object" && parsedOptions.model === "gemini-1.5-pro-latest" ? parsedOptions.jsonSchema : void 0
      },
      safetySettings
    };
    if (parsedOptions.systemInstruction !== "") {
      body.systemInstruction = {
        parts: [{ text: parsedOptions.systemInstruction }],
        role: "system"
      };
    }
    const response = await this.query(
      parsedOptions.model,
      command,
      body
    );
    if (parsedOptions.stream) {
      return this.handleStream(
        response,
        parsedOptions.format,
        parsedOptions.stream
      );
    }
    return this.switchFormat(parsedOptions.format)(await response.json());
  }
  createChat(options = {}) {
    return new Chat(this, options);
  }
};
_Gemini.TEXT = "text";
_Gemini.JSON = "json";
_Gemini.SafetyThreshold = SafetyThreshold;
_Gemini.SchemaType = SchemaType;
var Gemini = _Gemini;
var Chat = class {
  constructor(gemini, options) {
    const parsedOptions = __spreadValues(__spreadValues({}, {
      messages: [],
      temperature: 1,
      topP: 0.94,
      topK: 1,
      model: "gemini-1.5-flash-latest",
      maxOutputTokens: 2048,
      systemInstruction: ""
    }), options);
    this.gemini = gemini;
    this.options = parsedOptions;
    if (parsedOptions.messages[0] && Array.isArray(parsedOptions.messages[0])) {
      this.messages = parsedOptions.messages.flatMap(pairToMessage);
    } else {
      this.messages = parsedOptions.messages;
    }
  }
  async ask(message, options = {}) {
    var _a;
    const parsedConfig = __spreadValues(__spreadValues(__spreadValues({}, {
      data: [],
      format: Gemini.TEXT,
      safetySettings: {
        hate: Gemini.SafetyThreshold.BLOCK_SOME,
        sexual: Gemini.SafetyThreshold.BLOCK_SOME,
        harassment: Gemini.SafetyThreshold.BLOCK_SOME,
        dangerous: Gemini.SafetyThreshold.BLOCK_SOME
      },
      systemInstruction: "",
      jsonSchema: void 0
    }), this.options), options);
    if (((_a = this.messages.at(-1)) == null ? void 0 : _a.role) === "user") {
      throw new Error(
        "Gemini has not yet responded to your last message. Please ensure you are running chat commands asynchronously."
      );
    }
    let parsedMessage;
    if (!Array.isArray(message) && typeof message !== "string") {
      if (message.role === "model")
        throw new Error("Please prompt with role as 'user'");
      parsedMessage = message;
    } else {
      parsedMessage = {
        parts: await messageToParts([message].flat(), this.gemini),
        role: "user"
      };
    }
    const response = await this.gemini.ask(parsedMessage, __spreadProps(__spreadValues({}, parsedConfig), {
      format: Gemini.JSON,
      messages: this.messages,
      stream: parsedConfig.stream ? (res) => parsedConfig.stream(
        options.format === Gemini.JSON ? res : res.candidates[0].content.parts[0].text
      ) : void 0
    }));
    this.messages.push(parsedMessage);
    this.messages.push({
      parts: response.candidates[0].content.parts,
      role: "model"
    });
    return options.format === Gemini.JSON ? response : response.candidates[0].content.parts[0].text;
  }
};
var src_default = Gemini;
export {
  src_default as default,
  messageToParts
};
//# sourceMappingURL=index.mjs.map