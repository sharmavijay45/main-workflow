{"version":3,"sources":["../src/types.ts","../src/utils.ts","../src/index.ts"],"sourcesContent":["import { ProxyAgent } from \"undici\";\n\ntype FileType =\n\t| \"image/png\"\n\t| \"image/jpeg\"\n\t| \"image/webp\"\n\t| \"image/heic\"\n\t| \"image/heif\"\n\t| \"audio/wav\"\n\t| \"audio/mp3\"\n\t| \"audio/aiff\"\n\t| \"audio/aac\"\n\t| \"audio/ogg\"\n\t| \"audio/flac\"\n\t| \"video/mp4\"\n\t| \"video/mpeg\"\n\t| \"video/mov\"\n\t| \"video/avi\"\n\t| \"video/x-flv\"\n\t| \"video/mpg\"\n\t| \"video/webm\"\n\t| \"video/wmv\"\n\t| \"video/3gpp\";\n\ntype RemoteFilePart = { fileData: { mime_type: FileType; fileUri: string } };\n\ntype InlineFilePart = { inline_data: { mime_type: FileType; data: string } };\n\ntype TextPart = { text: string };\n\nexport type Part = TextPart | RemoteFilePart | InlineFilePart;\n\ntype Role = \"user\" | \"model\" | \"system\";\n\ntype SafetyRating = { category: string; probability: string };\n\nexport type Message = { parts: Part[]; role: Role };\n\nexport type PromptFeedback = {\n\tblockReason?: string;\n\tsafetyRatings: SafetyRating[];\n};\n\nexport type Candidate = {\n\tcontent: { parts: TextPart[]; role: Role };\n\tfinishReason: string;\n\tindex: number;\n\tsafetyRatings: SafetyRating[];\n};\n\nexport type GeminiResponse = {\n\tcandidates: Candidate[];\n\tpromptFeedback: PromptFeedback;\n};\n\nexport enum Command {\n\tStreamGenerate = \"streamGenerateContent\",\n\tGenerate = \"generateContent\",\n\tEmbed = \"embedContent\",\n\tCount = \"countTokens\",\n}\n\nexport enum HarmCategory {\n\tHateSpeech = \"HARM_CATEGORY_HATE_SPEECH\",\n\tSexuallyExplicit = \"HARM_CATEGORY_SEXUALLY_EXPLICIT\",\n\tHarassment = \"HARM_CATEGORY_HARASSMENT\",\n\tDangerousContent = \"HARM_CATEGORY_DANGEROUS_CONTENT\",\n}\n\n/**\n * The body used for the API call to generateContent or streamGenerateContent\n */\ntype GenerateContentBody = {\n\tcontents: Message[];\n\tgenerationConfig: {\n\t\tmaxOutputTokens: number;\n\t\ttemperature: number;\n\t\ttopP: number;\n\t\ttopK: number;\n\t\tresponseMimeType?: string;\n\t\tresponseSchema?: Schema;\n\t};\n\tsafetySettings: { category: HarmCategory; threshold: SafetyThreshold }[];\n\tsystemInstruction?: Message;\n};\n\n/**\n * The response from the REST API to generateContent or streamGenerateContent\n */\ntype GenerateContentQueryOutput = {\n\tcandidates: Candidate[];\n\tpromptFeedback: PromptFeedback;\n};\n\n/**\n * The body used for the API call for each command\n */\nexport type QueryBodyMap = {\n\t[Command.StreamGenerate]: GenerateContentBody;\n\t[Command.Generate]: GenerateContentBody;\n\t[Command.Count]: { contents: Message[] };\n\t[Command.Embed]: { model: string; content: Message };\n};\n\n/**\n * The response from the REST API for each command\n */\nexport type QueryResponseMap = {\n\t[Command.StreamGenerate]: GenerateContentQueryOutput;\n\t[Command.Generate]: GenerateContentQueryOutput;\n\t[Command.Embed]: {\n\t\tembedding: { values: number[] };\n\t};\n\t[Command.Count]: {\n\t\ttotalTokens: number;\n\t};\n};\n\n// These types are also directly used, as a string, in the Gemini class static properties\n// If you are to change these types, ensure to modify the statics in the Gemini class as well.\nexport type TextFormat = \"text\";\nexport type JSONFormat = \"json\";\nexport type Format = TextFormat | JSONFormat;\n\n/**\n * The output format for each command.\n */\nexport type CommandResponseMap<F extends Format = TextFormat> = {\n\t[Command.StreamGenerate]: F extends JSONFormat\n\t\t? QueryResponseMap[Command.StreamGenerate]\n\t\t: string;\n\t[Command.Generate]: F extends JSONFormat\n\t\t? QueryResponseMap[Command.Generate]\n\t\t: string;\n\t[Command.Embed]: number[];\n\t[Command.Count]: number;\n};\n\nexport type GeminiOptions = {\n\tfetch?: typeof fetch;\n\tapiVersion?: string;\n\tdispatcher?: ProxyAgent;\n};\n\n/**\n * The option format for each command.\n */\nexport type CommandOptionMap<F extends Format = TextFormat> = {\n\t[Command.Generate]: {\n\t\ttemperature: number;\n\t\ttopP: number;\n\t\ttopK: number;\n\t\tformat: F;\n\t\tmaxOutputTokens: number;\n\t\tmodel: string;\n\t\tdata: Buffer[];\n\t\tsystemInstruction: string;\n\t\tsafetySettings: {\n\t\t\thate: SafetyThreshold;\n\t\t\tsexual: SafetyThreshold;\n\t\t\tharassment: SafetyThreshold;\n\t\t\tdangerous: SafetyThreshold;\n\t\t};\n\t\tmessages: ([string, string] | Message)[];\n\t\tstream?(stream: CommandResponseMap<F>[Command.StreamGenerate]): void;\n\t\tjsonSchema: boolean | Schema;\n\t};\n\t[Command.Embed]: {\n\t\tmodel: string;\n\t};\n\t[Command.Count]: {\n\t\tmodel: string;\n\t};\n};\n\nexport enum SafetyThreshold {\n\t// Content with NEGLIGIBLE will be allowed.\n\tBLOCK_MOST = \"BLOCK_LOW_AND_ABOVE\",\n\t// Content with NEGLIGIBLE and LOW will be allowed.\n\tBLOCK_SOME = \"BLOCK_MEDIUM_AND_ABOVE\",\n\t// Content with NEGLIGIBLE, LOW, and MEDIUM will be allowed.\n\tBLOCK_FEW = \"BLOCK_ONLY_HIGH\",\n\t// All content will be allowed.\n\tBLOCK_NONE = \"BLOCK_NONE\",\n}\n\nexport type FormatType<T> = T extends JSONFormat ? GeminiResponse : string;\n\nexport type ChatOptions = {\n\tmessages: [string, string][] | Message[];\n\ttemperature: number;\n\ttopP: number;\n\ttopK: number;\n\tmodel: string;\n\tmaxOutputTokens: number;\n\tsystemInstruction: string;\n};\n\nexport type ChatAskOptions<F extends Format = TextFormat> = {\n\tformat: F;\n\tdata: [];\n\tstream?(stream: CommandResponseMap<F>[Command.StreamGenerate]): void;\n\tjsonSchema: boolean | Schema;\n};\n\nexport enum SchemaType {\n\t/** String type. */\n\tSTRING = \"STRING\",\n\t/** Number type. */\n\tNUMBER = \"NUMBER\",\n\t/** Integer type. */\n\tINTEGER = \"INTEGER\",\n\t/** Boolean type. */\n\tBOOLEAN = \"BOOLEAN\",\n\t/** Array type. */\n\tARRAY = \"ARRAY\",\n\t/** Object type. */\n\tOBJECT = \"OBJECT\",\n}\n\n/**\n * Schema is used to define the format of input/output data.\n * Represents a select subset of an OpenAPI 3.0 schema object.\n * More fields may be added in the future as needed.\n * @public\n */\nexport interface Schema {\n\t/**\n\t * Optional. The type of the property. {@link\n\t * FunctionDeclarationSchemaType}.\n\t */\n\ttype?: SchemaType;\n\t/** Optional. The format of the property. */\n\tformat?: string;\n\t/** Optional. The description of the property. */\n\tdescription?: string;\n\t/** Optional. Whether the property is nullable. */\n\tnullable?: boolean;\n\t/** Optional. The items of the property. {@link FunctionDeclarationSchema} */\n\titems?: FunctionDeclarationSchema;\n\t/** Optional. The enum of the property. */\n\tenum?: string[];\n\t/** Optional. Map of {@link FunctionDeclarationSchema}. */\n\tproperties?: { [k: string]: FunctionDeclarationSchema };\n\t/** Optional. Array of required property. */\n\trequired?: string[];\n\t/** Optional. The example of the property. */\n\texample?: unknown;\n}\n\n/**\n * Schema for parameters passed to {@link FunctionDeclaration.parameters}.\n * @public\n */\ninterface FunctionDeclarationSchema {\n\t/** The type of the parameter. */\n\ttype: SchemaType;\n\t/** The format of the parameter. */\n\tproperties: { [k: string]: Schema };\n\t/** Optional. Description of the parameter. */\n\tdescription?: string;\n\t/** Optional. Array of required parameters. */\n\trequired?: string[];\n}\n","import { FileTypeResult, fileTypeFromBuffer } from \"file-type\";\nimport type { GeminiResponse, Message } from \"./types\";\n\nexport const getFileType = async (buffer: Uint8Array | ArrayBuffer) => {\n\tconst fileType: FileTypeResult | undefined = await fileTypeFromBuffer(buffer);\n\n\tconst validMediaFormats = [\n\t\t\"image/png\",\n\t\t\"image/jpeg\",\n\t\t\"image/webp\",\n\t\t\"image/heic\",\n\t\t\"image/heif\",\n\t\t\"audio/wav\",\n\t\t\"audio/mp3\",\n\t\t\"audio/mpeg\",\n\t\t\"audio/aiff\",\n\t\t\"audio/aac\",\n\t\t\"audio/ogg\",\n\t\t\"audio/flac\",\n\t\t\"video/mp4\",\n\t\t\"video/mpeg\",\n\t\t\"video/mov\",\n\t\t\"video/avi\",\n\t\t\"video/x-flv\",\n\t\t\"video/mpg\",\n\t\t\"video/webm\",\n\t\t\"video/wmv\",\n\t\t\"video/3gpp\",\n\t];\n\n\tconst formatMap = {\n\t\t\"audio/mpeg\": \"audio/mp3\",\n\t};\n\n\tconst format = formatMap[fileType?.mime as string] || fileType?.mime;\n\n\tif (format === undefined || !validMediaFormats.includes(format))\n\t\tthrow new Error(\n\t\t\t\"Please provide a valid file format that is accepted by Gemini. Learn more about valid formats here: https://ai.google.dev/gemini-api/docs/prompting_with_media?lang=node#supported_file_formats\",\n\t\t);\n\n\treturn format;\n};\n\nexport class SafetyError extends Error {\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t\tthis.name = \"SafetyError\";\n\t}\n}\n\nexport const handleReader = async (\n\tresponse: Response,\n\tcb: (response: GeminiResponse) => void,\n) => {\n\tif (!response.body)\n\t\tthrow new Error(\n\t\t\t`An error occurred when attempting to read Gemini's response ${await response.text()}`,\n\t\t);\n\n\tconst decoder = new TextDecoder(\"utf-8\");\n\n\ttry {\n\t\t// This solution works for nearly every fetch, except for the node-fetch polyfill.\n\t\tconst reader = response.body.getReader();\n\n\t\tawait reader.read().then(function processText({ done, value }) {\n\t\t\tif (done) return;\n\n\t\t\tcb(JSON.parse(decoder.decode(value).replace(/^data: /, \"\")));\n\n\t\t\treturn reader.read().then(processText);\n\t\t});\n\t} catch (e) {\n\t\tif (e instanceof SafetyError) throw e;\n\t\t// This solution breaks on Safari or any fetch polyfill without AsyncIterators, but it works for node-fetch.\n\t\ttry {\n\t\t\t// response.body has an asyncIterator in modern most browsers\n\t\t\t// @ts-ignore\n\t\t\tfor await (const chunk of response.body) {\n\t\t\t\tcb(JSON.parse(decoder.decode(chunk).replace(/^data: /, \"\")));\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tif (err instanceof SafetyError) throw err;\n\t\t\tthrow new Error(\n\t\t\t\t`An error occurred when attempting to stream content from Gemini: ${err.stack}`,\n\t\t\t);\n\t\t}\n\t}\n};\n\nexport const pairToMessage = (message: [string, string]): Message[] => {\n\treturn [\n\t\t{\n\t\t\tparts: [{ text: message[0] }],\n\t\t\trole: \"user\",\n\t\t},\n\t\t{\n\t\t\tparts: [{ text: message[1] }],\n\t\t\trole: \"model\",\n\t\t},\n\t];\n};\n","import { Command, HarmCategory, SafetyThreshold, SchemaType } from \"./types\";\n\nimport type {\n\tChatAskOptions,\n\tChatOptions,\n\tCommandOptionMap,\n\tCommandResponseMap,\n\tFormat,\n\tFormatType,\n\tGeminiOptions,\n\tGeminiResponse,\n\tMessage,\n\tPart,\n\tQueryBodyMap,\n\tQueryResponseMap,\n} from \"./types\";\n\nimport { SafetyError, getFileType, handleReader, pairToMessage } from \"./utils\";\n\nconst uploadFile = async ({\n\tfile,\n\tmimeType,\n\tgemini,\n}: {\n\tfile: Uint8Array | ArrayBuffer;\n\tmimeType: string;\n\tgemini: Gemini;\n}) => {\n\tconst BASE_URL = \"https://generativelanguage.googleapis.com\";\n\n\tfunction generateBoundary() {\n\t\tlet str = \"\";\n\t\tfor (let i = 0; i < 2; i++) {\n\t\t\tstr = str + Math.random().toString().slice(2);\n\t\t}\n\t\treturn str;\n\t}\n\n\tconst boundary = generateBoundary();\n\n\tconst generateBlob = (\n\t\tboundary: string,\n\t\tfile: Uint8Array | ArrayBuffer,\n\t\tmime: string,\n\t) =>\n\t\tnew Blob([\n\t\t\t`--${boundary}\\r\\nContent-Type: application/json; charset=utf-8\\r\\n\\r\\n${JSON.stringify(\n\t\t\t\t{\n\t\t\t\t\tfile: {\n\t\t\t\t\t\tmimeType: mime,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t)}\\r\\n--${boundary}\\r\\nContent-Type: ${mime}\\r\\n\\r\\n`,\n\t\t\tfile,\n\t\t\t`\\r\\n--${boundary}--`,\n\t\t]);\n\n\tconst fileSendDataRaw = await gemini\n\t\t.fetch(`${BASE_URL}/upload/${gemini.apiVersion}/files?key=${gemini.key}`, {\n\t\t\tmethod: \"POST\",\n\t\t\theaders: {\n\t\t\t\t\"Content-Type\": `multipart/related; boundary=${boundary}`,\n\t\t\t\t\"X-Goog-Upload-Protocol\": \"multipart\",\n\t\t\t},\n\t\t\tbody: generateBlob(boundary, file, mimeType),\n\t\t})\n\t\t.then((res: Response) => res.json());\n\n\tconst fileSendData = fileSendDataRaw.file;\n\n\tlet waitTime = 250; // Initial wait time in milliseconds\n\tconst MAX_BACKOFF = 5000; // Maximum backoff time in milliseconds\n\n\t// Keep polling until the file state is \"ACTIVE\"\n\twhile (true) {\n\t\ttry {\n\t\t\tconst url = `${BASE_URL}/${gemini.apiVersion}/${fileSendData.name}?key=${gemini.key}`;\n\n\t\t\tconst response = await gemini.fetch(url, { method: \"GET\" });\n\t\t\tconst data = await response.json();\n\n\t\t\tif (data.error) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Google's File API responded with an error: ${data.error.message}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (data.state === \"ACTIVE\") break;\n\n\t\t\tawait new Promise((resolve) => setTimeout(resolve, waitTime));\n\n\t\t\twaitTime = Math.min(waitTime * 1.5, MAX_BACKOFF);\n\t\t} catch (error) {\n\t\t\tthrow new Error(\n\t\t\t\t`An error occurred while uploading to Google's File API: ${error.message}`,\n\t\t\t);\n\t\t}\n\t}\n\n\treturn fileSendData.uri;\n};\n\nexport const messageToParts = async (\n\tmessages: (Uint8Array | ArrayBuffer | string)[],\n\tgemini: Gemini,\n): Promise<Part[]> => {\n\tconst parts = [];\n\tlet totalBytes = 0;\n\n\tfor (const msg of messages) {\n\t\tif (typeof msg === \"string\") {\n\t\t\tparts.push({ text: msg });\n\t\t} else if (msg instanceof ArrayBuffer || msg instanceof Uint8Array) {\n\t\t\ttotalBytes += Buffer.from(msg).byteLength;\n\t\t\tconst mimeType = await getFileType(msg);\n\t\t\tif (!mimeType.startsWith(\"video\")) {\n\t\t\t\tparts.push({\n\t\t\t\t\tinline_data: {\n\t\t\t\t\t\tmime_type: await getFileType(msg),\n\t\t\t\t\t\tdata: Buffer.from(msg).toString(\"base64\"),\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tconst fileURI = await uploadFile({\n\t\t\t\t\tfile: msg,\n\t\t\t\t\tmimeType: mimeType,\n\t\t\t\t\tgemini: gemini,\n\t\t\t\t});\n\t\t\t\tparts.push({\n\t\t\t\t\tfileData: {\n\t\t\t\t\t\tmime_type: mimeType,\n\t\t\t\t\t\tfileUri: fileURI,\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\tif (totalBytes > 20 * 1024 * 1024) {\n\t\tfor (const idx in parts) {\n\t\t\tconst part = parts[idx];\n\t\t\tif (part.inline_data) {\n\t\t\t\tconst fileURI = await uploadFile({\n\t\t\t\t\tfile: Buffer.from(part.inline_data.data, \"base64\"),\n\t\t\t\t\tmimeType: part.inline_data.mime_type,\n\t\t\t\t\tgemini: gemini,\n\t\t\t\t});\n\t\t\t\tparts[idx] = {\n\t\t\t\t\tfileData: {\n\t\t\t\t\t\tmime_type: part.inline_data.mime_type,\n\t\t\t\t\t\tfileUri: fileURI,\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\treturn parts;\n};\n\nclass Gemini {\n\treadonly key: string;\n\treadonly apiVersion: string;\n\treadonly fetch: typeof fetch;\n\n\tstatic TEXT = \"text\" as const;\n\tstatic JSON = \"json\" as const;\n\tstatic SafetyThreshold = SafetyThreshold;\n\tstatic SchemaType = SchemaType;\n\n\tconstructor(key: string, options: Partial<GeminiOptions> = {}) {\n\t\tif (!options.fetch && typeof fetch !== \"function\") {\n\t\t\tthrow new Error(\n\t\t\t\t\"Fetch is not defined globally. Please provide a polyfill. Learn more here: https://github.com/EvanZhouDev/gemini-ai?tab=readme-ov-file#how-to-polyfill-fetch\",\n\t\t\t);\n\t\t}\n\n\t\tconst parsedOptions: GeminiOptions = {\n\t\t\t...{\n\t\t\t\tapiVersion: \"v1beta\",\n\t\t\t\tfetch: typeof fetch === \"function\" ? fetch : options.fetch,\n\t\t\t},\n\t\t\t...options,\n\t\t};\n\n\t\tthis.key = key;\n\t\tthis.fetch = parsedOptions.fetch;\n\t\tthis.apiVersion = parsedOptions.apiVersion;\n\t}\n\n\tasync query<C extends Command>(\n\t\tmodel: string,\n\t\tcommand: C,\n\t\tbody: QueryBodyMap[C],\n\t): Promise<Response> {\n\t\tconst opts = {\n\t\t\tmethod: \"POST\",\n\t\t\theaders: {\n\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t},\n\t\t\tbody: JSON.stringify(body),\n\t\t};\n\n\t\tconst url = new URL(\n\t\t\t`https://generativelanguage.googleapis.com/${this.apiVersion}/models/${model}:${command}`,\n\t\t);\n\n\t\turl.searchParams.append(\"key\", this.key);\n\t\tif (command === Command.StreamGenerate)\n\t\t\turl.searchParams.append(\"alt\", \"sse\");\n\n\t\tconst response = await this.fetch(url.toString(), opts);\n\n\t\tif (!response.ok) {\n\t\t\tthrow new Error(\n\t\t\t\t`There was an error when querying Gemini.\\n${await response.text()}`,\n\t\t\t);\n\t\t}\n\n\t\treturn response;\n\t}\n\n\tasync count(\n\t\tmessage: string,\n\t\toptions: Partial<CommandOptionMap[Command.Count]> = {},\n\t): Promise<CommandResponseMap[Command.Count]> {\n\t\tconst parsedOptions: CommandOptionMap[Command.Count] = {\n\t\t\t...{\n\t\t\t\tmodel: \"gemini-1.5-flash-latest\",\n\t\t\t},\n\t\t\t...options,\n\t\t};\n\n\t\tconst body: QueryBodyMap[Command.Count] = {\n\t\t\tcontents: [\n\t\t\t\t{\n\t\t\t\t\tparts: [{ text: message }],\n\t\t\t\t\trole: \"user\",\n\t\t\t\t},\n\t\t\t],\n\t\t};\n\n\t\tconst response: Response = await this.query(\n\t\t\tparsedOptions.model,\n\t\t\tCommand.Count,\n\t\t\tbody,\n\t\t);\n\n\t\tconst output: QueryResponseMap[Command.Count] = await response.json();\n\t\treturn output.totalTokens;\n\t}\n\n\tasync embed(\n\t\tmessage: string,\n\t\toptions: Partial<CommandOptionMap[Command.Embed]> = {},\n\t) {\n\t\tconst parsedOptions: CommandOptionMap[Command.Embed] = {\n\t\t\t...{\n\t\t\t\tmodel: \"embedding-001\",\n\t\t\t},\n\t\t\t...options,\n\t\t};\n\n\t\tconst body: QueryBodyMap[Command.Embed] = {\n\t\t\tmodel: `models/${parsedOptions.model}`,\n\t\t\tcontent: {\n\t\t\t\tparts: [{ text: message }],\n\t\t\t\trole: \"user\",\n\t\t\t},\n\t\t};\n\n\t\tconst response: Response = await this.query(\n\t\t\tparsedOptions.model,\n\t\t\tCommand.Embed,\n\t\t\tbody,\n\t\t);\n\n\t\tconst output: QueryResponseMap[Command.Embed] = await response.json();\n\t\treturn output.embedding.values;\n\t}\n\n\tprivate getTextObject = (response: GeminiResponse) =>\n\t\tresponse.candidates[0].content.parts[0];\n\n\tprivate switchFormat =\n\t\t<F extends Format>(format: F = Gemini.TEXT as F) =>\n\t\t(response: GeminiResponse): FormatType<F> => {\n\t\t\tif (response.candidates[0].finishReason === \"SAFETY\") {\n\t\t\t\tthrow new SafetyError(\n\t\t\t\t\t`Your prompt was blocked by Google. Here are the Harm Categories: \\n${JSON.stringify(\n\t\t\t\t\t\tresponse.candidates[0].safetyRatings,\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\t4,\n\t\t\t\t\t)}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tswitch (format) {\n\t\t\t\tcase Gemini.TEXT:\n\t\t\t\t\treturn this.getTextObject(response).text as FormatType<F>;\n\t\t\t\tcase Gemini.JSON:\n\t\t\t\t\treturn response as FormatType<F>;\n\t\t\t}\n\t\t};\n\n\tprivate getText = this.switchFormat(Gemini.TEXT);\n\n\tprivate handleStream = async <F extends Format>(\n\t\tresponse: Response,\n\t\tformat: F,\n\t\tcb: (response: FormatType<F>) => void,\n\t) => {\n\t\tconst formatter: (response: GeminiResponse) => FormatType<F> =\n\t\t\tthis.switchFormat(format);\n\n\t\tlet res: GeminiResponse;\n\t\tlet text = \"\";\n\n\t\tawait handleReader(response, (value: GeminiResponse) => {\n\t\t\tres = value;\n\t\t\ttext += this.getText(value);\n\n\t\t\tcb(formatter(value));\n\t\t});\n\n\t\tthis.getTextObject(res).text = text;\n\n\t\treturn formatter(res);\n\t};\n\n\tasync ask<F extends Format = typeof Gemini.TEXT>(\n\t\tmessage: string | (string | Uint8Array | ArrayBuffer)[] | Message,\n\t\toptions: Partial<CommandOptionMap<F>[Command.Generate]> = {},\n\t): Promise<CommandResponseMap<F>[Command.Generate]> {\n\t\tconst parsedOptions: CommandOptionMap<F>[Command.Generate] = {\n\t\t\t...{\n\t\t\t\tmodel: \"gemini-1.5-flash-latest\",\n\t\t\t\ttemperature: 1,\n\t\t\t\ttopP: 0.94,\n\t\t\t\ttopK: 32,\n\t\t\t\tformat: Gemini.TEXT as F,\n\t\t\t\tmaxOutputTokens: 2048,\n\t\t\t\tdata: [],\n\t\t\t\tmessages: [],\n\t\t\t\tsafetySettings: {\n\t\t\t\t\thate: Gemini.SafetyThreshold.BLOCK_SOME,\n\t\t\t\t\tsexual: Gemini.SafetyThreshold.BLOCK_SOME,\n\t\t\t\t\tharassment: Gemini.SafetyThreshold.BLOCK_SOME,\n\t\t\t\t\tdangerous: Gemini.SafetyThreshold.BLOCK_SOME,\n\t\t\t\t},\n\t\t\t\tsystemInstruction: \"\",\n\t\t\t\tjsonSchema: undefined,\n\t\t\t},\n\t\t\t...options,\n\t\t};\n\n\t\tconst safetySettings = [\n\t\t\t{\n\t\t\t\tcategory: HarmCategory.HateSpeech,\n\t\t\t\tthreshold: parsedOptions.safetySettings.hate,\n\t\t\t},\n\t\t\t{\n\t\t\t\tcategory: HarmCategory.SexuallyExplicit,\n\t\t\t\tthreshold: parsedOptions.safetySettings.sexual,\n\t\t\t},\n\t\t\t{\n\t\t\t\tcategory: HarmCategory.Harassment,\n\t\t\t\tthreshold: parsedOptions.safetySettings.harassment,\n\t\t\t},\n\t\t\t{\n\t\t\t\tcategory: HarmCategory.DangerousContent,\n\t\t\t\tthreshold: parsedOptions.safetySettings.dangerous,\n\t\t\t},\n\t\t];\n\n\t\tconst command = parsedOptions.stream\n\t\t\t? Command.StreamGenerate\n\t\t\t: Command.Generate;\n\n\t\tconst contents = [\n\t\t\t...parsedOptions.messages.flatMap(\n\t\t\t\t(msg: [string, string] | Message) => {\n\t\t\t\t\tif (Array.isArray(msg)) {\n\t\t\t\t\t\treturn pairToMessage(msg);\n\t\t\t\t\t}\n\t\t\t\t\treturn msg;\n\t\t\t\t},\n\t\t\t),\n\t\t];\n\n\t\tif (!Array.isArray(message) && typeof message !== \"string\") {\n\t\t\tif (message.role === \"model\")\n\t\t\t\tthrow new Error(\"Please prompt with role as 'user'\");\n\t\t\tcontents.push(message);\n\t\t} else {\n\t\t\tconst messageParts = [message, parsedOptions.data].flat();\n\t\t\tconst parts = await messageToParts(messageParts, this);\n\n\t\t\tif (\n\t\t\t\tparsedOptions.jsonSchema &&\n\t\t\t\tparsedOptions.model !== \"gemini-1.5-pro-latest\"\n\t\t\t) {\n\t\t\t\tparts.push({\n\t\t\t\t\ttext: `Use this JSON schema: <JSONSchema>${JSON.stringify(\n\t\t\t\t\t\tparsedOptions.jsonSchema,\n\t\t\t\t\t)}</JSONSchema>`,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tcontents.push({\n\t\t\t\tparts: parts,\n\t\t\t\trole: \"user\",\n\t\t\t});\n\t\t}\n\n\t\tconst body: QueryBodyMap[typeof command] = {\n\t\t\tcontents,\n\t\t\tgenerationConfig: {\n\t\t\t\ttemperature: parsedOptions.temperature,\n\t\t\t\tmaxOutputTokens: parsedOptions.maxOutputTokens,\n\t\t\t\ttopP: parsedOptions.topP,\n\t\t\t\ttopK: parsedOptions.topK,\n\t\t\t\tresponseMimeType: parsedOptions.jsonSchema\n\t\t\t\t\t? \"application/json\"\n\t\t\t\t\t: undefined,\n\t\t\t\tresponseSchema:\n\t\t\t\t\ttypeof parsedOptions.jsonSchema === \"object\" &&\n\t\t\t\t\tparsedOptions.model === \"gemini-1.5-pro-latest\"\n\t\t\t\t\t\t? parsedOptions.jsonSchema\n\t\t\t\t\t\t: undefined,\n\t\t\t},\n\t\t\tsafetySettings,\n\t\t};\n\n\t\tif (parsedOptions.systemInstruction !== \"\") {\n\t\t\tbody.systemInstruction = {\n\t\t\t\tparts: [{ text: parsedOptions.systemInstruction }],\n\t\t\t\trole: \"system\",\n\t\t\t};\n\t\t}\n\n\t\tconst response: Response = await this.query(\n\t\t\tparsedOptions.model,\n\t\t\tcommand,\n\t\t\tbody,\n\t\t);\n\n\t\tif (parsedOptions.stream) {\n\t\t\treturn this.handleStream(\n\t\t\t\tresponse,\n\t\t\t\tparsedOptions.format,\n\t\t\t\tparsedOptions.stream,\n\t\t\t);\n\t\t}\n\n\t\treturn this.switchFormat(parsedOptions.format)(await response.json());\n\t}\n\n\tcreateChat(options: Partial<ChatOptions> = {}) {\n\t\treturn new Chat(this, options);\n\t}\n}\n\nclass Chat {\n\tgemini: Gemini;\n\toptions: ChatOptions;\n\tmessages: Message[];\n\n\tconstructor(gemini: Gemini, options?: Partial<ChatOptions>) {\n\t\tconst parsedOptions: ChatOptions = {\n\t\t\t...{\n\t\t\t\tmessages: [],\n\t\t\t\ttemperature: 1,\n\t\t\t\ttopP: 0.94,\n\t\t\t\ttopK: 1,\n\t\t\t\tmodel: \"gemini-1.5-flash-latest\",\n\t\t\t\tmaxOutputTokens: 2048,\n\t\t\t\tsystemInstruction: \"\",\n\t\t\t},\n\t\t\t...options,\n\t\t};\n\n\t\tthis.gemini = gemini;\n\t\tthis.options = parsedOptions;\n\n\t\tif (parsedOptions.messages[0] && Array.isArray(parsedOptions.messages[0])) {\n\t\t\t// @ts-ignore It is ensured that parsedOptions.messages is [string, string][] with the above check.\n\t\t\tthis.messages = parsedOptions.messages.flatMap(pairToMessage);\n\t\t} else {\n\t\t\tthis.messages = parsedOptions.messages as Message[];\n\t\t}\n\t}\n\n\tasync ask<F extends Format = typeof Gemini.TEXT>(\n\t\tmessage: string | (string | Uint8Array | ArrayBuffer)[] | Message,\n\t\toptions: Partial<ChatAskOptions<F>> = {},\n\t): Promise<CommandResponseMap<F>[Command.Generate]> {\n\t\tconst parsedConfig: CommandOptionMap<F>[Command.Generate] = {\n\t\t\t...{\n\t\t\t\tdata: [],\n\t\t\t\tformat: Gemini.TEXT as F,\n\t\t\t\tsafetySettings: {\n\t\t\t\t\thate: Gemini.SafetyThreshold.BLOCK_SOME,\n\t\t\t\t\tsexual: Gemini.SafetyThreshold.BLOCK_SOME,\n\t\t\t\t\tharassment: Gemini.SafetyThreshold.BLOCK_SOME,\n\t\t\t\t\tdangerous: Gemini.SafetyThreshold.BLOCK_SOME,\n\t\t\t\t},\n\t\t\t\tsystemInstruction: \"\",\n\t\t\t\tjsonSchema: undefined,\n\t\t\t},\n\t\t\t...this.options,\n\t\t\t...options,\n\t\t};\n\n\t\tif (this.messages.at(-1)?.role === \"user\") {\n\t\t\tthrow new Error(\n\t\t\t\t\"Gemini has not yet responded to your last message. Please ensure you are running chat commands asynchronously.\",\n\t\t\t);\n\t\t}\n\n\t\tlet parsedMessage: Message;\n\t\tif (!Array.isArray(message) && typeof message !== \"string\") {\n\t\t\tif (message.role === \"model\")\n\t\t\t\tthrow new Error(\"Please prompt with role as 'user'\");\n\t\t\tparsedMessage = message;\n\t\t} else {\n\t\t\tparsedMessage = {\n\t\t\t\tparts: await messageToParts([message].flat(), this.gemini),\n\t\t\t\trole: \"user\",\n\t\t\t};\n\t\t}\n\n\t\tconst response = await this.gemini.ask(parsedMessage, {\n\t\t\t...parsedConfig,\n\t\t\tformat: Gemini.JSON,\n\t\t\tmessages: this.messages,\n\t\t\tstream: parsedConfig.stream\n\t\t\t\t? (res) =>\n\t\t\t\t\t\tparsedConfig.stream(\n\t\t\t\t\t\t\toptions.format === Gemini.JSON\n\t\t\t\t\t\t\t\t? (res as FormatType<F>)\n\t\t\t\t\t\t\t\t: (res.candidates[0].content.parts[0].text as FormatType<F>),\n\t\t\t\t\t\t)\n\t\t\t\t: undefined,\n\t\t});\n\n\t\tthis.messages.push(parsedMessage);\n\t\tthis.messages.push({\n\t\t\tparts: response.candidates[0].content.parts,\n\t\t\trole: \"model\",\n\t\t});\n\n\t\treturn options.format === Gemini.JSON\n\t\t\t? (response as FormatType<F>)\n\t\t\t: (response.candidates[0].content.parts[0].text as FormatType<F>);\n\t}\n}\n\nexport default Gemini;\n\nexport type {\n\tFormat,\n\tMessage,\n\tPart,\n\tGeminiResponse,\n\tCommandResponseMap,\n\tCommandOptionMap,\n\tGeminiOptions,\n\tChatOptions,\n\tChatAskOptions,\n};\n"],"mappings":"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","names":["SafetyThreshold","SchemaType","boundary","file"]}